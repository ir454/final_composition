<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Wireframe Building in WebGL</title>
<style>
    body { margin:0; overflow:hidden; background:#111; }
    canvas { display:block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById("glcanvas");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;
const gl = canvas.getContext("webgl");

if (!gl) {
    alert("WebGL not supported");
}

/* Vertex shader */
const vsSource = `
attribute vec3 aPosition;
uniform mat4 uProjection;
uniform mat4 uView;
uniform mat4 uModel;
void main() {
    gl_Position = uProjection * uView * uModel * vec4(aPosition,1.0);
}`;

/* Fragment shader */
const fsSource = `
precision mediump float;
uniform vec3 uColor;
void main() {
    gl_FragColor = vec4(uColor,1.0);
}`;

/* Compile shader */
function createShader(gl,type,source){
    const shader = gl.createShader(type);
    gl.shaderSource(shader,source);
    gl.compileShader(shader);
    if(!gl.getShaderParameter(shader,gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(shader));
        return null;
    }
    return shader;
}

/* Create program */
function createProgram(gl,vs,fs){
    const program = gl.createProgram();
    gl.attachShader(program,vs);
    gl.attachShader(program,fs);
    gl.linkProgram(program);
    if(!gl.getProgramParameter(program,gl.LINK_STATUS)){
        console.error(gl.getProgramInfoLog(program));
        return null;
    }
    return program;
}

const vertexShader = createShader(gl,gl.VERTEX_SHADER,vsSource);
const fragmentShader = createShader(gl,gl.FRAGMENT_SHADER,fsSource);
const program = createProgram(gl,vertexShader,fragmentShader);
gl.useProgram(program);

/* Cube wireframe vertices */
const cubeVertices = new Float32Array([
    -0.5,-0.5,-0.5,  0.5,-0.5,-0.5,
     0.5,-0.5,-0.5,  0.5, 0.5,-0.5,
     0.5, 0.5,-0.5, -0.5, 0.5,-0.5,
    -0.5, 0.5,-0.5, -0.5,-0.5,-0.5,

    -0.5,-0.5, 0.5,  0.5,-0.5, 0.5,
     0.5,-0.5, 0.5,  0.5, 0.5, 0.5,
     0.5, 0.5, 0.5, -0.5, 0.5, 0.5,
    -0.5, 0.5, 0.5, -0.5,-0.5, 0.5,

    -0.5,-0.5,-0.5, -0.5,-0.5, 0.5,
     0.5,-0.5,-0.5,  0.5,-0.5, 0.5,
     0.5, 0.5,-0.5,  0.5, 0.5, 0.5,
    -0.5, 0.5,-0.5, -0.5, 0.5, 0.5
]);

const cubeBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, cubeBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

const aPosition = gl.getAttribLocation(program, "aPosition");
gl.enableVertexAttribArray(aPosition);
gl.vertexAttribPointer(aPosition,3,gl.FLOAT,false,0,0);

const uProjection = gl.getUniformLocation(program,"uProjection");
const uView = gl.getUniformLocation(program,"uView");
const uModel = gl.getUniformLocation(program,"uModel");
const uColor = gl.getUniformLocation(program,"uColor");

/* Basic matrix math */
function perspective(fovy,aspect,near,far){
    const f = 1.0/Math.tan(fovy/2);
    return [
        f/aspect,0,0,0,
        0,f,0,0,
        0,0,(far+near)/(near-far),-1,
        0,0,(2*far*near)/(near-far),0
    ];
}

function lookAt(eye,target,up){
    const z = normalize(subtract(eye,target));
    const x = normalize(cross(up,z));
    const y = cross(z,x);
    return [
        x[0],y[0],z[0],0,
        x[1],y[1],z[1],0,
        x[2],y[2],z[2],0,
        -dot(x,eye),-dot(y,eye),-dot(z,eye),1
    ];
}

function multiply(a,b){
    const out = new Array(16);
    for(let i=0;i<4;i++){
        for(let j=0;j<4;j++){
            out[j*4+i] = a[i]*b[j*4]+a[i+4]*b[j*4+1]+a[i+8]*b[j*4+2]+a[i+12]*b[j*4+3];
        }
    }
    return out;
}

function translate(x,y,z){
    return [1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1];
}
function dot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function cross(a,b){return [a[1]*b[2]-a[2]*b[1], a[2]*b[0]-a[0]*b[2], a[0]*b[1]-a[1]*b[0]];}
function subtract(a,b){return [a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
function normalize(v){const len=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]); return [v[0]/len,v[1]/len,v[2]/len];}

/* Projection & View */
const proj = perspective(Math.PI/4,canvas.width/canvas.height,0.1,100);
const view = lookAt([15,20,40],[0,8,0],[0,1,0]);

gl.uniformMatrix4fv(uProjection,false,new Float32Array(proj));
gl.uniformMatrix4fv(uView,false,new Float32Array(view));
gl.uniform3f(uColor,0,1,1);

gl.enable(gl.DEPTH_TEST);

/* Draw loop */
function draw(){
    gl.clearColor(0.07,0.07,0.07,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    const towerCount = 4;
    const towerHeight = 10;

    for(let t=0;t<towerCount;t++){
        const towerX = (t-(towerCount-1)/2)*4;
        for(let y=0;y<towerHeight;y++){
            const zOffset = (Math.random()-0.5)*1.5;
            const xOffset = (Math.random()-0.5)*1.5;
            const model = translate(towerX+xOffset, y, zOffset);
            gl.uniformMatrix4fv(uModel,false,new Float32Array(model));
            gl.drawArrays(gl.LINES,0,cubeVertices.length/3);
        }
    }

    requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>
