<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Flying Sculptural Sequencer</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ===============================
   THREE.JS SETUP
   =============================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0, 5, 30);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* LIGHTS */
scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
dirLight.position.set(50,100,50);
scene.add(dirLight);

/* ===============================
   CREATE SCULPTURE WITH VARIOUS SHAPES
   =============================== */
const sculpture = new THREE.Group();
scene.add(sculpture);

const shapes = ['box','sphere','cone','torus','cylinder'];
const cubes = [];
const shapeCount = 40;
const spread = 15;

for(let i=0; i<shapeCount; i++){
  const type = shapes[Math.floor(Math.random()*shapes.length)];
  let geom;
  switch(type){
    case 'box': geom = new THREE.BoxGeometry(1,1,1); break;
    case 'sphere': geom = new THREE.SphereGeometry(0.8, 10, 10); break;
    case 'cone': geom = new THREE.ConeGeometry(0.8, 1.5, 8); break;
    case 'torus': geom = new THREE.TorusGeometry(0.6, 0.2, 8, 16); break;
    case 'cylinder': geom = new THREE.CylinderGeometry(0.5,0.5,1.5,8); break;
  }

  const mat = new THREE.MeshBasicMaterial({color:0x00ffcc, wireframe:true});
  const mesh = new THREE.Mesh(geom, mat);

  mesh.position.set(
    (Math.random()-0.5)*spread,
    (Math.random()-0.5)*spread,
    (Math.random()-0.5)*spread
  );

  mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
  sculpture.add(mesh);

  cubes.push({
    mesh: mesh,
    basePos: mesh.position.clone(),
    phase: Math.random()*Math.PI*2,
    scalePulse: 0
  });
}

/* ===============================
   WEB AUDIO SETUP
   =============================== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const Cminor = [261.63, 311.13, 392.00, 523.25, 466.16]; // C, Eb, G, C5, Bb
let cubeIndex = 0;

function playNote(freq, cube){
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.05, audioCtx.currentTime);

  const panner = audioCtx.createPanner();
  panner.panningModel = 'HRTF';
  panner.distanceModel = 'inverse';
  panner.positionX.setValueAtTime(cube.mesh.position.x, audioCtx.currentTime);
  panner.positionY.setValueAtTime(cube.mesh.position.y, audioCtx.currentTime);
  panner.positionZ.setValueAtTime(cube.mesh.position.z, audioCtx.currentTime);

  osc.connect(panner).connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.25);

  cube.scalePulse = 0.5;
}

/* ===============================
   ANIMATE SCENE & CAMERA
   =============================== */
let cameraPathTime = 0;
function animate(){
  requestAnimationFrame(animate);
  const t = performance.now()*0.001;

  // Animate shapes
  cubes.forEach((c)=>{
    const floatX = Math.sin(t + c.phase)*0.3;
    const floatY = Math.cos(t*1.3 + c.phase)*0.3;
    const floatZ = Math.sin(t*0.7 + c.phase)*0.3;
    c.mesh.position.x = c.basePos.x + floatX;
    c.mesh.position.y = c.basePos.y + floatY;
    c.mesh.position.z = c.basePos.z + floatZ;

    c.mesh.rotation.x += 0.01;
    c.mesh.rotation.y += 0.01;

    c.scalePulse *= 0.88;
    const scale = 0.8 + c.scalePulse;
    c.mesh.scale.set(scale, scale, scale);
  });

  // Camera flies through sculpture
  cameraPathTime += 0.003;
  camera.position.x = Math.sin(cameraPathTime*0.7)*20;
  camera.position.y = Math.sin(cameraPathTime*0.5)*5 + 5;
  camera.position.z = Math.cos(cameraPathTime*0.7)*20;
  camera.lookAt(0,0,0);

  sculpture.rotation.y += 0.0008;

  renderer.render(scene, camera);

  // Melodic sequencer
  if(!animate.lastPlay) animate.lastPlay = t;
  if(t - animate.lastPlay > 0.25){
    const freq = Cminor[cubeIndex % Cminor.length];
    playNote(freq, cubes[cubeIndex]);
    cubeIndex = (cubeIndex + 1) % cubes.length;
    animate.lastPlay = t;
  }
}
animate();

/* ===============================
   HANDLE RESIZE
   =============================== */
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* CLICK TO START AUDIO CONTEXT */
document.body.addEventListener('click', ()=>{
  if(audioCtx.state === 'suspended') audioCtx.resume();
});
</script>
</body>
</html>
