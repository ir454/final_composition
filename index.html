<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Audio Visual Experience</title>
<style>
  body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
  canvas { display: block; }

  #uiContainer {
    position: absolute;
    top: 10px;
    left: 10px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    background: rgba(0,0,0,0.4);
    padding: 10px;
    border-radius: 8px;
  }

  #timer { font-size: 28px; color: white; font-weight: bold; text-align: center; }

  #startAudio {
    padding: 8px 16px;
    background: #ff4444;
    color: white;
    font-size: 16px;
    border: none;
    cursor: pointer;
    border-radius: 6px;
  }

  #miniMap {
    width: 150px;
    height: 150px;
    background: #111;
    border: 2px solid white;
    border-radius: 6px;
    cursor: pointer;
  }

  /* Controls box */
  #controls {
    color: white;
    font-size: 14px;
    background: rgba(0,0,0,0.45);
    padding: 8px;
    border-radius: 6px;
    line-height: 1.3em;
  }
  #controls ul {
    margin: 6px 0 0 16px;
    padding: 0;
    list-style-type: disc;
  }
  #controls li { margin-bottom: 3px; }

</style>
</head>
<body>

<div id="uiContainer">
  <div id="timer">05:00</div>
  <canvas id="miniMap"></canvas>
  <button id="startAudio">Click to Enable Sound</button>

  <div id="controls">
    <strong>Controls:</strong>
    <ul>
      <li>Move: W A S D</li>
      <li>Look: Arrow Keys</li>
      <li>Move Circle to You: 1â€“4</li>
      <li>Mini-Map: Click a circle, then drag to move it</li>
    </ul>
  </div>
</div>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

/* ============================================================
   SCENE SETUP
============================================================ */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 200);
camera.position.set(0,1.5,15);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ============================================================
   FLOOR
============================================================ */
const floorSize = 60;
const floorSegments = 60;
const floorGeometry = new THREE.PlaneGeometry(floorSize,floorSize,floorSegments,floorSegments);
const floorMaterial = new THREE.MeshBasicMaterial({color:0xffffff, wireframe:true, transparent:true, opacity:0.5});
const floorMesh = new THREE.Mesh(floorGeometry,floorMaterial);
floorMesh.rotation.x = -Math.PI/2;
scene.add(floorMesh);

/* ============================================================
   LIGHT
============================================================ */
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(5,10,7);
scene.add(light);

/* ============================================================
   FLOATING CIRCLES
============================================================ */
const circles = [];
const circlePositions = [
    new THREE.Vector3(-10,0.5,-10),
    new THREE.Vector3(10,0.5,-10),
    new THREE.Vector3(-10,0.5,10),
    new THREE.Vector3(10,0.5,10)
];
const neonColors = [0xff00ff,0x00ffff,0xffff00,0xff5500];

for(let i=0;i<4;i++){
    const mat = new THREE.MeshStandardMaterial({
        color: neonColors[i],
        emissive: neonColors[i],
        emissiveIntensity: 0.6
    });
    const circle = new THREE.Mesh(new THREE.SphereGeometry(1,16,16), mat);
    circle.position.copy(circlePositions[i]);
    scene.add(circle);

    circles.push({
        mesh: circle,
        currentColor: new THREE.Color(neonColors[i]),
        targetColor: new THREE.Color(neonColors[i]),
        baseY: circle.position.y
    });
}

/* ============================================================
   SEGMENTS AROUND CIRCLES
============================================================ */
const segmentsPerCircle = 15;
const circleSegments = [];

for(let i=0;i<4;i++){
    const segs = [];
    for(let j=0;j<segmentsPerCircle;j++){
        const geom = new THREE.BufferGeometry();
        geom.setAttribute('position', new THREE.BufferAttribute(new Float32Array(6),3));
        const mat = new THREE.LineBasicMaterial({color: neonColors[i]});
        const line = new THREE.Line(geom, mat);
        scene.add(line);
        segs.push({line, geom});
    }
    circleSegments.push(segs);
}

/* ============================================================
   USER MOVEMENT
============================================================ */
const keys = {};
document.addEventListener("keydown", e => keys[e.key] = true);
document.addEventListener("keyup", e => delete keys[e.key]);

let yaw = 0, pitch = 0;

function updateMovement(){
    const moveSpeed = 0.13, rotSpeed = 0.02;

    if(keys["ArrowLeft"]) yaw += rotSpeed;
    if(keys["ArrowRight"]) yaw -= rotSpeed;
    if(keys["ArrowUp"]) pitch += rotSpeed;
    if(keys["ArrowDown"]) pitch -= rotSpeed;

    camera.rotation.set(pitch, yaw, 0);

    const forward = new THREE.Vector3(-Math.sin(yaw),0,-Math.cos(yaw));
    const right = new THREE.Vector3(Math.cos(yaw),0,-Math.sin(yaw));

    if(keys["w"]||keys["W"]) camera.position.addScaledVector(forward, moveSpeed);
    if(keys["s"]||keys["S"]) camera.position.addScaledVector(forward, -moveSpeed);
    if(keys["a"]||keys["A"]) camera.position.addScaledVector(right, -moveSpeed);
    if(keys["d"]||keys["D"]) camera.position.addScaledVector(right, moveSpeed);

    // Move circles to player
    if(keys["1"]){ circles[0].mesh.position.copy(camera.position); circles[0].mesh.position.y = 1; delete keys["1"]; }
    if(keys["2"]){ circles[1].mesh.position.copy(camera.position); circles[1].mesh.position.y = 1; delete keys["2"]; }
    if(keys["3"]){ circles[2].mesh.position.copy(camera.position); circles[2].mesh.position.y = 1; delete keys["3"]; }
    if(keys["4"]){ circles[3].mesh.position.copy(camera.position); circles[3].mesh.position.y = 1; delete keys["4"]; }
}

/* ============================================================
   AUDIO ENGINE
============================================================ */
let audioCtx, audioStarted=false;
const circleAudio = [];

const baseMelody = [261.63, 311.13, 349.23, 392.00, 466.16].map(n => n * 0.5);
const melody = [];
for(let o=0;o<3;o++){
    const mul = Math.pow(2,o);
    baseMelody.forEach(n => melody.push(n * mul));
}

function createImpulseResponse(ctx,duration=1.0,decay=1.0){
    const rate = ctx.sampleRate;
    const length = rate * duration;
    const impulse = ctx.createBuffer(2,length,rate);
    const left = impulse.getChannelData(0);
    const right = impulse.getChannelData(1);

    for(let i=0;i<length;i++){
        const n = (length - i) / length;
        const v = Math.random() * Math.pow(n, decay);
        left[i] = v;
        right[i] = v;
    }
    return impulse;
}

function startAudio(){
    audioCtx = new AudioContext();
    const reverb = createImpulseResponse(audioCtx);

    for(let i=0;i<4;i++){
        const osc = audioCtx.createOscillator();
        osc.type = "triangle";

        const panner = audioCtx.createPanner();
        panner.panningModel = "HRTF";

        const lowpass = audioCtx.createBiquadFilter();
        lowpass.type = "lowpass";

        const convolver = audioCtx.createConvolver();
        convolver.buffer = reverb;

        const reverbGain = audioCtx.createGain();
        reverbGain.gain.value = 0.1;

        const gain = audioCtx.createGain();
        gain.gain.value = 0;

        osc.connect(panner);
        panner.connect(lowpass);
        lowpass.connect(gain);
        gain.connect(audioCtx.destination);

        osc.connect(convolver);
        convolver.connect(reverbGain);
        reverbGain.connect(audioCtx.destination);

        osc.start();

        circleAudio.push({
            osc, gain, panner, lowpass,
            nextNoteTime: audioCtx.currentTime + Math.random()*1.5,
            noteDuration: 0.2 + Math.random()*0.2,
            currentFreq: 0,
            currentVolume: 0,
            lastNoteColor: new THREE.Color(neonColors[i]),
            pointillistic: false
        });
    }

    audioStarted = true;
    document.getElementById("startAudio").style.display = "none";
    startTimer();
}

/* ============================================================
   TIMER
============================================================ */
let timerSeconds = 300;
let timerInterval = null;

function startTimer(){
    timerInterval = setInterval(() => {
        timerSeconds--;

        if(timerSeconds === 240) startDrumMachine();
        if(timerSeconds === 120) stopDrumMachine();
        if(timerSeconds === 60){
            circleAudio.forEach(c => c.pointillistic = true);
        }

        if(timerSeconds <= 10 && timerSeconds > 0){
            const fade = timerSeconds / 10;
            circleAudio.forEach(c => {
                c.gain.gain.linearRampToValueAtTime(fade*0.3, audioCtx.currentTime + 0.1);
            });
        }

        if(timerSeconds <= 0){
            clearInterval(timerInterval);
            stopAudio();
            stopDrumMachine();
        }

        const min = String(Math.floor(timerSeconds/60)).padStart(2,'0');
        const sec = String(timerSeconds % 60).padStart(2,'0');
        document.getElementById("timer").innerText = `${min}:${sec}`;
    }, 1000);
}

/* ============================================================
   MELODY UPDATE
============================================================ */
function updateMelody(){
    if(!audioStarted) return;
    const now = audioCtx.currentTime;

    circleAudio.forEach((c,i) => {
        if(now >= c.nextNoteTime){
            const freq = melody[Math.floor(Math.random() * melody.length)];
            const color = new THREE.Color(`hsl(${Math.random()*360},100%,50%)`);
            circles[i].targetColor.copy(color);
            c.lastNoteColor = color;

            c.osc.frequency.cancelScheduledValues(now);
            c.osc.frequency.setValueAtTime(c.currentFreq || freq, now);
            c.osc.frequency.exponentialRampToValueAtTime(freq, now + 0.08);

            const g = c.gain.gain;
            g.cancelScheduledValues(now);

            if(c.pointillistic){
                g.setValueAtTime(0.0001, now);
                g.linearRampToValueAtTime(0.3, now + 0.02);
                g.linearRampToValueAtTime(0.0001, now + 0.08);
                c.noteDuration = 0.05 + Math.random()*0.1;
                c.nextNoteTime = now + 0.15 + Math.random()*0.2;
            } else {
                g.setValueAtTime(0.0001, now);
                g.linearRampToValueAtTime(0.3, now + 0.05);
                g.linearRampToValueAtTime(0.0001, now + c.noteDuration);
                c.noteDuration = 0.15 + Math.random()*0.25;
                c.nextNoteTime = now + 0.4 + Math.random()*0.8;
            }

            c.currentFreq = freq;
        }
    });
}

/* ============================================================
   SPATIAL AUDIO
============================================================ */
function updateAudioSpatial(){
    if(!audioStarted) return;

    audioCtx.listener.positionX.value = camera.position.x;
    audioCtx.listener.positionY.value = camera.position.y;
    audioCtx.listener.positionZ.value = camera.position.z;

    const forward = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation);
    audioCtx.listener.forwardX.value = forward.x;
    audioCtx.listener.forwardY.value = forward.y;
    audioCtx.listener.forwardZ.value = forward.z;

    audioCtx.listener.upX.value = 0;
    audioCtx.listener.upY.value = 1;
    audioCtx.listener.upZ.value = 0;

    for(let i=0;i<4;i++){
        const src = circleAudio[i];
        const pos = circles[i].mesh.position;

        src.panner.positionX.value = pos.x;
        src.panner.positionY.value = pos.y;
        src.panner.positionZ.value = pos.z;

        const dist = camera.position.distanceTo(pos);
        const t = Math.min(dist / 25, 1);

        const vol = Math.pow(1-t, 3);
        src.gain.gain.linearRampToValueAtTime(vol, audioCtx.currentTime + 0.1);
        src.currentVolume = vol;

        const cutoff = 600 + (20000 - 600) * Math.pow(1-t, 2.2);
        src.lowpass.frequency.linearRampToValueAtTime(cutoff, audioCtx.currentTime + 0.1);
    }
}

/* ============================================================
   VISUALS
============================================================ */
function updateCirclesVisuals(){
    const time = performance.now() / 1000;

    for(let i=0;i<4;i++){
        const c = circles[i];

        c.mesh.position.y = c.baseY + Math.sin(time+i)*0.3;

        c.currentColor.lerp(c.targetColor, 0.02);
        c.mesh.material.color.copy(c.currentColor);
        c.mesh.material.emissive.copy(c.currentColor);

        const segs = circleSegments[i];
        const freq = circleAudio[i]?.currentFreq || 440;
        const amp = circleAudio[i]?.currentVolume || 0;

        for(let j=0;j<segs.length;j++){
            const seg = segs[j];
            const len = 2*(0.5+amp)*Math.sin(freq*time + j);

            const pos = seg.geom.attributes.position.array;
            pos[0]=0; pos[1]=0; pos[2]=0;
            pos[3]=0; pos[4]=len; pos[5]=0;

            seg.geom.attributes.position.needsUpdate = true;

            const brightness = 0.5 + 0.5*amp;
            seg.line.material.color.copy(c.currentColor).multiplyScalar(brightness);
        }
    }
}

/* ============================================================
   MINI-MAP
============================================================ */
const miniMap = document.getElementById("miniMap");
const miniCtx = miniMap.getContext("2d");
miniMap.width = miniMap.clientWidth;
miniMap.height = miniMap.clientHeight;

let selectedCircleIndex = null;
let dragging = false;

function miniMapToWorld(mx, my){
    const worldX = (mx / miniMap.width) * floorSize - floorSize/2;
    const worldZ = (my / miniMap.height) * floorSize - floorSize/2;
    return {worldX, worldZ};
}

miniMap.addEventListener("mousedown", (e)=>{
    const rect = miniMap.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (miniMap.width / rect.width);
    const my = (e.clientY - rect.top) * (miniMap.height / rect.height);

    selectedCircleIndex = null;
    dragging = false;

    for(let i=0;i<circles.length;i++){
        const cx = (circles[i].mesh.position.x + floorSize/2) / floorSize * miniMap.width;
        const cy = (circles[i].mesh.position.z + floorSize/2) / floorSize * miniMap.height;

        const dx = mx - cx;
        const dy = my - cy;

        if(dx*dx + dy*dy < 25){
            selectedCircleIndex = i;
            dragging = true;
            return;
        }
    }
});

miniMap.addEventListener("mousemove", (e)=>{
    if(!dragging || selectedCircleIndex === null) return;

    const rect = miniMap.getBoundingClientRect();
    const mx = (e.clientX - rect.left) * (miniMap.width / rect.width);
    const my = (e.clientY - rect.top) * (miniMap.height / rect.height);

    const {worldX, worldZ} = miniMapToWorld(mx, my);
    circles[selectedCircleIndex].mesh.position.set(worldX, 1, worldZ);
});

miniMap.addEventListener("mouseup", ()=>{
    dragging = false;
    selectedCircleIndex = null;
});
miniMap.addEventListener("mouseleave", ()=>{
    dragging = false;
    selectedCircleIndex = null;
});

function updateMiniMap(){
    miniCtx.clearRect(0,0,miniMap.width,miniMap.height);

    circles.forEach((c,i)=>{
        const x = (c.mesh.position.x + floorSize/2) / floorSize * miniMap.width;
        const y = (c.mesh.position.z + floorSize/2) / floorSize * miniMap.height;

        miniCtx.beginPath();
        miniCtx.arc(x, y, 5, 0, Math.PI*2);
        miniCtx.fillStyle = `#${c.currentColor.getHexString()}`;
        miniCtx.fill();
    });
}

/* ============================================================
   DRUM MACHINE
============================================================ */
let drumActive = false;
let drumInterval = null;
const drumPosition = new THREE.Vector3(0,3,0);
const rectangles = [];

function startDrumMachine(){
    if(!audioStarted || drumActive) return;
    drumActive = true;

    for(let i=0;i<10;i++){
        const geo = new THREE.BoxGeometry(0.5,0.5,0.5);
        const mat = new THREE.MeshStandardMaterial({color: 0xffffff, emissive:0xffffff});
        const rect = new THREE.Mesh(geo, mat);
        rect.position.set(drumPosition.x, drumPosition.y, drumPosition.z);
        scene.add(rect);
        rectangles.push(rect);
    }

    drumInterval = setInterval(()=>{
        rectangles.forEach((rect,i)=>{
            rect.position.y = drumPosition.y + Math.random()*2;
            rect.material.color.setHSL(Math.random(),1,0.5);
        });
    },200);
}

function stopDrumMachine(){
    drumActive=false;
    clearInterval(drumInterval);
    rectangles.forEach(r=>scene.remove(r));
    rectangles.length = 0;
}

/* ============================================================
   STOP AUDIO
============================================================ */
function stopAudio(){
    if(!audioStarted) return;
    circleAudio.forEach(c=>{
        c.osc.stop();
        c.gain.disconnect();
        c.panner.disconnect();
    });
}

/* ============================================================
   ANIMATION LOOP
============================================================ */
function animate(){
    requestAnimationFrame(animate);

    updateMovement();
    updateMelody();
    updateAudioSpatial();
    updateCirclesVisuals();
    updateMiniMap();

    renderer.render(scene, camera);
}
animate();

/* ============================================================
   START AUDIO BUTTON
============================================================ */
document.getElementById("startAudio").addEventListener("click", startAudio);

window.addEventListener("resize", ()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    miniMap.width = miniMap.clientWidth;
    miniMap.height = miniMap.clientHeight;
});
</script>

</body>
</html>
