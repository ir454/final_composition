<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Immersive Audio-Visual Sculpture</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
/* ===============================
   THREE.JS SETUP
   =============================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);
scene.fog = new THREE.FogExp2(0x111111, 0.02);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,5,30);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* POST-PROCESSING BLOOM */
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);
const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.8, 0.5, 0.8);
composer.addPass(bloomPass);

/* LIGHTS */
scene.add(new THREE.AmbientLight(0xffffff, 0.3));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
dirLight.position.set(50,100,50);
scene.add(dirLight);

const pulseLights = [];
for(let i=0;i<5;i++){
  const light = new THREE.PointLight(0x00ffcc, 0.5, 30);
  light.position.set(Math.random()*40-20, Math.random()*20-10, Math.random()*40-20);
  scene.add(light);
  pulseLights.push(light);
}

/* ===============================
   SCULPTURE WITH VARIOUS SHAPES
   =============================== */
const sculpture = new THREE.Group();
scene.add(sculpture);

const shapes = ['box','sphere','cone','torus','cylinder'];
const cubes = [];
const shapeCount = 50;
const spread = 20;

for(let i=0; i<shapeCount; i++){
  const type = shapes[Math.floor(Math.random()*shapes.length)];
  let geom;
  switch(type){
    case 'box': geom = new THREE.BoxGeometry(1,1,1); break;
    case 'sphere': geom = new THREE.SphereGeometry(0.8, 12, 12); break;
    case 'cone': geom = new THREE.ConeGeometry(0.8, 1.5, 10); break;
    case 'torus': geom = new THREE.TorusGeometry(0.6, 0.2, 10, 16); break;
    case 'cylinder': geom = new THREE.CylinderGeometry(0.5,0.5,1.5,10); break;
  }

  const mat = new THREE.MeshStandardMaterial({
    color: 0x00ffcc,
    wireframe:true,
    emissive: 0x00ffcc,
    emissiveIntensity: 0.3
  });
  const mesh = new THREE.Mesh(geom, mat);

  mesh.position.set(
    (Math.random()-0.5)*spread,
    (Math.random()-0.5)*spread,
    (Math.random()-0.5)*spread
  );

  mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
  sculpture.add(mesh);

  cubes.push({
    mesh: mesh,
    basePos: mesh.position.clone(),
    phase: Math.random()*Math.PI*2,
    scalePulse: 0,
    colorPulse: 0,
    seqOffset: Math.floor(Math.random()*20)
  });
}

/* ===============================
   WEB AUDIO
   =============================== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const Cminor = [261.63, 311.13, 392.00, 466.16, 523.25]; // C, Eb, G, Bb, C5
const colorMap = [0xff5555, 0xffaa00, 0xffff55, 0x55ff55, 0x55aaff];
let globalStep = 0;

function playNote(freq, cube, noteIndex){
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.05, audioCtx.currentTime);

  const panner = audioCtx.createPanner();
  panner.panningModel = 'HRTF';
  panner.distanceModel = 'inverse';
  panner.positionX.setValueAtTime(cube.mesh.position.x, audioCtx.currentTime);
  panner.positionY.setValueAtTime(cube.mesh.position.y, audioCtx.currentTime);
  panner.positionZ.setValueAtTime(cube.mesh.position.z, audioCtx.currentTime);

  osc.connect(panner).connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.25);

  cube.scalePulse = 0.6;
  cube.colorPulse = 1;
  cube.targetColor = colorMap[noteIndex % colorMap.length];

  // pulse lights
  pulseLights.forEach((l,i)=>{
    l.intensity = 0.5 + Math.random()*0.5;
    l.color.setHex(colorMap[(noteIndex+i)%colorMap.length]);
  });
}

/* ===============================
   ANIMATE SCENE & CAMERA
   =============================== */
let lastTime = 0;
let cameraTime = 0;
let cameraPulse = 0;

function animate(){
  requestAnimationFrame(animate);
  const t = performance.now()*0.001;

  // Animate cubes
  cubes.forEach((c)=>{
    const floatX = Math.sin(t*1.2 + c.phase)*0.4;
    const floatY = Math.cos(t*0.9 + c.phase)*0.4;
    const floatZ = Math.sin(t*0.7 + c.phase)*0.4;
    c.mesh.position.x = c.basePos.x + floatX;
    c.mesh.position.y = c.basePos.y + floatY;
    c.mesh.position.z = c.basePos.z + floatZ;

    c.mesh.rotation.x += 0.01 + 0.01*Math.sin(t + c.seqOffset);
    c.mesh.rotation.y += 0.01 + 0.01*Math.cos(t + c.seqOffset);

    // scale pulse
    c.scalePulse *= 0.85;
    const scale = 0.8 + 0.3*Math.sin(t + c.seqOffset*0.5) + c.scalePulse;
    c.mesh.scale.set(scale, scale, scale);

    // color pulse
    if(c.colorPulse > 0){
      c.mesh.material.emissive.setHex(c.targetColor);
      c.mesh.material.color.setHex(c.targetColor);
      c.colorPulse *= 0.8;
    } else {
      c.mesh.material.emissive.setHex(0x00ffcc);
      c.mesh.material.color.setHex(0x00ffcc);
    }
  });

  // Camera moves through scene
  cameraTime += 0.005;
  const pulseFactor = 1 + cameraPulse*0.5;
  camera.position.x = (Math.sin(cameraTime*1.2)*25 + Math.sin(cameraTime*0.7)*10)*pulseFactor;
  camera.position.y = (Math.sin(cameraTime*0.8)*10 + 5)*pulseFactor;
  camera.position.z = (Math.cos(cameraTime*1.3)*25 + Math.cos(cameraTime*0.6)*10)*pulseFactor;
  camera.lookAt(0,0,0);

  sculpture.rotation.y += 0.001;

  composer.render();

  // Sequencer rhythm
  if(!lastTime) lastTime = t;
  if(t - lastTime > 0.15){
    cubes.forEach((c, i)=>{
      if((globalStep + c.seqOffset) % 20 === 0){
        const freq = Cminor[i % Cminor.length];
        playNote(freq, c, i);
        cameraPulse = 1;
      }
    });
    globalStep++;
    lastTime = t;
  }

  cameraPulse *= 0.85;
}
animate();

/* ===============================
   RESIZE
   =============================== */
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});

/* CLICK TO START AUDIO */
document.body.addEventListener('click', ()=>{
  if(audioCtx.state === 'suspended') audioCtx.resume();
});
</script>
</body>
</html>
