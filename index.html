<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive Audio-Visual Sculpture</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script>
/* ===============================
   THREE.JS SETUP
   =============================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,5,30);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
dirLight.position.set(50,100,50);
scene.add(dirLight);

/* ===============================
   SCULPTURE WITH VARIOUS SHAPES
   =============================== */
const sculpture = new THREE.Group();
scene.add(sculpture);

const shapes = ['box','sphere','cone','torus','cylinder'];
const cubes = [];
const shapeCount = 60;
const spread = 20;

for(let i=0; i<shapeCount; i++){
  const type = shapes[Math.floor(Math.random()*shapes.length)];
  let geom;
  switch(type){
    case 'box': geom = new THREE.BoxGeometry(1,1,1); break;
    case 'sphere': geom = new THREE.SphereGeometry(0.8, 12, 12); break;
    case 'cone': geom = new THREE.ConeGeometry(0.8, 1.5, 10); break;
    case 'torus': geom = new THREE.TorusGeometry(0.6, 0.2, 10, 16); break;
    case 'cylinder': geom = new THREE.CylinderGeometry(0.5,0.5,1.5,10); break;
  }

  const mat = new THREE.MeshBasicMaterial({color:0x00ffcc, wireframe:true});
  const mesh = new THREE.Mesh(geom, mat);

  mesh.position.set(
    (Math.random()-0.5)*spread,
    (Math.random()-0.5)*spread,
    (Math.random()-0.5)*spread
  );

  mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
  sculpture.add(mesh);

  cubes.push({
    mesh: mesh,
    basePos: mesh.position.clone(),
    phase: Math.random()*Math.PI*2,
    scalePulse: 0,
    seqOffset: Math.floor(Math.random()*20)
  });
}

/* ===============================
   WEB AUDIO
   =============================== */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
const Cminor = [261.63, 311.13, 392.00, 466.16, 523.25]; // C, Eb, G, Bb, C5
let globalStep = 0;

function playNote(freq, cube){
  const osc = audioCtx.createOscillator();
  osc.type = 'sine';
  osc.frequency.setValueAtTime(freq, audioCtx.currentTime);

  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.05, audioCtx.currentTime);

  const panner = audioCtx.createPanner();
  panner.panningModel = 'HRTF';
  panner.distanceModel = 'inverse';
  panner.positionX.setValueAtTime(cube.mesh.position.x, audioCtx.currentTime);
  panner.positionY.setValueAtTime(cube.mesh.position.y, audioCtx.currentTime);
  panner.positionZ.setValueAtTime(cube.mesh.position.z, audioCtx.currentTime);

  osc.connect(panner).connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime + 0.25);

  cube.scalePulse = 0.6; // strong pulse
}

/* ===============================
   ANIMATE SCENE & CAMERA
   =============================== */
let lastTime = 0;
let cameraTime = 0;
let cameraPulse = 0;

function animate(){
  requestAnimationFrame(animate);
  const t = performance.now()*0.001;

  // Animate cubes: floating, rotation, staggered scale pulse
  cubes.forEach((c)=>{
    const floatX = Math.sin(t*1.2 + c.phase)*0.4;
    const floatY = Math.cos(t*0.9 + c.phase)*0.4;
    const floatZ = Math.sin(t*0.7 + c.phase)*0.4;
    c.mesh.position.x = c.basePos.x + floatX;
    c.mesh.position.y = c.basePos.y + floatY;
    c.mesh.position.z = c.basePos.z + floatZ;

    c.mesh.rotation.x += 0.01 + 0.01*Math.sin(t + c.seqOffset);
    c.mesh.rotation.y += 0.01 + 0.01*Math.cos(t + c.seqOffset);

    c.scalePulse *= 0.85;
    const scale = 0.8 + 0.3*Math.sin(t + c.seqOffset*0.5) + c.scalePulse;
    c.mesh.scale.set(scale, scale, scale);
  });

  // Camera responds to pulse rhythm
  cameraTime += 0.005;
  const pulseFactor = 1 + cameraPulse*0.5;
  camera.position.x = (Math.sin(cameraTime*1.2)*25 + Math.sin(cameraTime*0.7)*10)*pulseFactor;
  camera.position.y = (Math.sin(cameraTime*0.8)*10 + 5)*pulseFactor;
  camera.position.z = (Math.cos(cameraTime*1.3)*25 + Math.cos(cameraTime*0.6)*10)*pulseFactor;
  camera.lookAt(0,0,0);

  sculpture.rotation.y += 0.001;

  renderer.render(scene, camera);

  // Sequencer rhythm: staggered
  if(!lastTime) lastTime = t;
  if(t - lastTime > 0.15){
    cubes.forEach((c, i)=>{
      if((globalStep + c.seqOffset) % 20 === 0){
        const freq = Cminor[i % Cminor.length];
        playNote(freq, c);
        cameraPulse = 1; // camera pulse triggered
      }
    });
    globalStep++;
    lastTime = t;
  }

  // decay camera pulse
  cameraPulse *= 0.85;
}
animate();

/* ===============================
   RESIZE
   =============================== */
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* CLICK TO START AUDIO */
document.body.addEventListener('click', ()=>{
  if(audioCtx.state === 'suspended') audioCtx.resume();
});
</script>
</body>
</html>
