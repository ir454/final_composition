<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Optimized Breathing Möbius Sculpture</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; }
</style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

<script>
/* ===============================
   THREE.JS SETUP
   =============================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 500);
camera.position.set(0,5,30);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* POST-PROCESSING BLOOM */
const composer = new THREE.EffectComposer(renderer);
composer.addPass(new THREE.RenderPass(scene, camera));
composer.addPass(new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 0.6, 0.4, 0.6));

/* LIGHTS */
scene.add(new THREE.AmbientLight(0xffffff, 0.3));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
dirLight.position.set(50,100,50);
scene.add(dirLight);

/* PULSE LIGHTS */
const pulseLights = [];
for(let i=0;i<3;i++){
  const light = new THREE.PointLight(0x00ffcc, 0.5, 30);
  light.position.set(Math.random()*30-15, Math.random()*15-7.5, Math.random()*30-15);
  scene.add(light);
  pulseLights.push(light);
}

/* ===============================
   SCULPTURE WITH OPTIMIZED MÖBIUS STRIPS
   =============================== */
const sculpture = new THREE.Group();
scene.add(sculpture);

const shapes = [];
const shapeCount = 20;
const spread = 15;

function createMobiusMesh(radius, tube, p, q) {
  const geom = new THREE.MobiusStripGeometry(radius, tube, 12, 60, p, q);
  geom.dynamic = true; // allow vertex update
  const mat = new THREE.MeshStandardMaterial({
    color:0x00ffcc, wireframe:true, emissive:0x00ffcc, emissiveIntensity:0.3
  });
  return new THREE.Mesh(geom, mat);
}

for(let i=0;i<shapeCount;i++){
  const radius = 0.5 + Math.random()*1.5;
  const tube = 0.1 + Math.random()*0.3;
  const p = Math.random()*2*Math.PI;
  const q = 1 + Math.floor(Math.random()*3);

  const mesh = createMobiusMesh(radius, tube, p, q);
  mesh.position.set((Math.random()-0.5)*spread, (Math.random()-0.5)*spread, (Math.random()-0.5)*spread);
  mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
  sculpture.add(mesh);

  shapes.push({mesh, radius, tube, p, q, phase: Math.random()*Math.PI*2, scalePulse:0, colorPulse:0, seqOffset: Math.floor(Math.random()*20)});
}

/* ===============================
   WEB AUDIO
   =============================== */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
const Cminor = [261.63, 311.13, 392.00, 466.16, 523.25];
const colors = [0xff5555,0xffaa00,0xffff55,0x55ff55,0x55aaff];
let step=0;

function playNote(freq, shape, idx){
  const osc = audioCtx.createOscillator();
  osc.type='sine';
  osc.frequency.setValueAtTime(freq,audioCtx.currentTime);

  const gain = audioCtx.createGain();
  gain.gain.setValueAtTime(0.05,audioCtx.currentTime);

  const pan = audioCtx.createPanner();
  pan.panningModel='HRTF';
  pan.positionX.setValueAtTime(shape.mesh.position.x,audioCtx.currentTime);
  pan.positionY.setValueAtTime(shape.mesh.position.y,audioCtx.currentTime);
  pan.positionZ.setValueAtTime(shape.mesh.position.z,audioCtx.currentTime);

  osc.connect(pan).connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime+0.25);

  shape.scalePulse=0.6;
  shape.colorPulse=1;
  shape.targetColor = colors[idx%colors.length];

  pulseLights.forEach((l,i)=>l.color.setHex(colors[(idx+i)%colors.length]));
}

/* ===============================
   ANIMATION LOOP
   =============================== */
let lastTime=0;
let camTime=0;
let camPulse=0;

function animate(){
  requestAnimationFrame(animate);
  const t = performance.now()*0.001;

  shapes.forEach((s,i)=>{
    // Morph vertices
    const geom = s.mesh.geometry;
    for(let j=0;j<geom.attributes.position.count;j++){
      const x = geom.attributes.position.getX(j);
      const y = geom.attributes.position.getY(j);
      const z = geom.attributes.position.getZ(j);
      geom.attributes.position.setXYZ(j,
        x*(1+0.1*Math.sin(t+s.phase)),
        y*(1+0.1*Math.cos(t+s.phase)),
        z*(1+0.1*Math.sin(t*0.7+s.phase))
      );
    }
    geom.attributes.position.needsUpdate=true;

    // Float & rotate
    s.mesh.position.x = s.mesh.position.x + Math.sin(t*1.2 + s.phase)*0.001;
    s.mesh.position.y = s.mesh.position.y + Math.cos(t*0.9 + s.phase)*0.001;
    s.mesh.position.z = s.mesh.position.z + Math.sin(t*0.7 + s.phase)*0.001;

    s.mesh.rotation.x += 0.01 + 0.01*Math.sin(t+s.seqOffset);
    s.mesh.rotation.y += 0.01 + 0.01*Math.cos(t+s.seqOffset);

    // Scale pulse
    s.scalePulse *= 0.85;
    const scale = 0.8 + s.scalePulse;
    s.mesh.scale.set(scale, scale, scale);

    // Color pulse
    if(s.colorPulse>0){
      s.mesh.material.color.setHex(s.targetColor);
      s.mesh.material.emissive.setHex(s.targetColor);
      s.colorPulse*=0.8;
    } else {
      s.mesh.material.color.setHex(0x00ffcc);
      s.mesh.material.emissive.setHex(0x00ffcc);
    }
  });

  // Camera flythrough
  camTime+=0.004;
  const pulseF = 1+camPulse*0.5;
  camera.position.set(Math.sin(camTime*1.2)*25*pulseF, 5+Math.sin(camTime*0.8)*10*pulseF, Math.cos(camTime*1.3)*25*pulseF);
  camera.lookAt(0,0,0);
  camPulse*=0.85;

  composer.render();

  // Sequencer
  if(!lastTime) lastTime=t;
  if(t-lastTime>0.15){
    shapes.forEach((s,i)=>{
      if((step+s.seqOffset)%20===0){
        const freq = Cminor[i%Cminor.length];
        playNote(freq,s,i);
        camPulse=1;
      }
    });
    step++;
    lastTime=t;
  }
}
animate();

/* ===============================
   RESIZE
   =============================== */
window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
});

/* CLICK TO START AUDIO */
document.body.addEventListener('click',()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); });
</script>
</body>
</html>
