<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Interactive Torus Sculpture FPS</title>
<style>
  body { margin:0; overflow:hidden; background:#111; }
  canvas { display:block; }
  #crosshair {
    position: absolute;
    top: 50%; left: 50%;
    width: 20px; height: 20px;
    margin-left: -10px; margin-top: -10px;
    pointer-events: none;
  }
  #crosshair:before, #crosshair:after {
    content: '';
    position: absolute;
    background: #00ffcc;
  }
  #crosshair:before { left: 50%; top:0; width:2px; height:100%; transform: translateX(-50%); }
  #crosshair:after { top: 50%; left:0; width:100%; height:2px; transform: translateY(-50%); }
  #instructions {
    position: absolute;
    width: 100%; text-align:center;
    top: 50%; color:#00ffcc;
    font-family: sans-serif; font-size: 24px;
  }
</style>
</head>
<body>
<div id="crosshair"></div>
<div id="instructions">Click to start. WASD + Mouse to move.</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.160.0/examples/js/controls/PointerLockControls.js"></script>
<script>
/* ===============================
   THREE.JS SETUP
=============================== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x111111);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,2,5);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* LIGHT */
scene.add(new THREE.AmbientLight(0xffffff,0.5));

/* ===============================
   TORUSES
=============================== */
const sculpture = new THREE.Group();
scene.add(sculpture);

const shapes = [];
const shapeCount = 15;
const spread = 20;

function createTorus(radius,tube){
  const geom = new THREE.TorusGeometry(radius, tube, 8, 30);
  const mat = new THREE.MeshStandardMaterial({color:0x00ffcc, wireframe:true});
  return new THREE.Mesh(geom, mat);
}

for(let i=0;i<shapeCount;i++){
  const radius = 0.5 + Math.random()*1.5;
  const tube = 0.1 + Math.random()*0.3;
  const mesh = createTorus(radius, tube);
  mesh.position.set((Math.random()-0.5)*spread,(Math.random()-0.5)*spread,(Math.random()-0.5)*spread);
  mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
  sculpture.add(mesh);
  shapes.push({mesh, phase: Math.random()*Math.PI*2, baseScale: mesh.scale.clone()});
}

/* ===============================
   WEB AUDIO
=============================== */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
const Cminor = [261.63,311.13,392,466,523];
let step=0;

function playNote(freq,shape){
  const osc = audioCtx.createOscillator();
  osc.type='sine';
  osc.frequency.value=freq;

  const gain = audioCtx.createGain();
  gain.gain.value = 0.05;

  const panner = audioCtx.createPanner();
  panner.panningModel='HRTF';
  panner.positionX.value = shape.mesh.position.x;
  panner.positionY.value = shape.mesh.position.y;
  panner.positionZ.value = shape.mesh.position.z;

  osc.connect(panner).connect(gain).connect(audioCtx.destination);
  osc.start();
  osc.stop(audioCtx.currentTime+0.2);
}

/* ===============================
   FPS CONTROLS
=============================== */
const controls = new THREE.PointerLockControls(camera, document.body);
const instructions = document.getElementById('instructions');
instructions.addEventListener('click', () => { controls.lock(); });

controls.addEventListener('lock', () => { instructions.style.display = 'none'; });
controls.addEventListener('unlock', () => { instructions.style.display = ''; });

const velocity = new THREE.Vector3();
const direction = new THREE.Vector3();
const move = { forward:false, backward:false, left:false, right:false };

document.addEventListener('keydown', e => {
  if(e.code==='KeyW') move.forward=true;
  if(e.code==='KeyS') move.backward=true;
  if(e.code==='KeyA') move.left=true;
  if(e.code==='KeyD') move.right=true;
});
document.addEventListener('keyup', e => {
  if(e.code==='KeyW') move.forward=false;
  if(e.code==='KeyS') move.backward=false;
  if(e.code==='KeyA') move.left=false;
  if(e.code==='KeyD') move.right=false;
});

/* ===============================
   ANIMATE
=============================== */
const clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  const t = clock.getElapsedTime();

  // Rotate toruses
  shapes.forEach((s,i)=>{
    s.mesh.rotation.x += 0.01 + 0.01*Math.sin(t+s.phase);
    s.mesh.rotation.y += 0.01 + 0.01*Math.cos(t+s.phase);
  });

  // Movement
  const delta = clock.getDelta();
  velocity.x -= velocity.x * 10.0 * delta;
  velocity.z -= velocity.z * 10.0 * delta;
  direction.z = Number(move.forward)-Number(move.backward);
  direction.x = Number(move.right)-Number(move.left);
  direction.normalize();
  if(move.forward || move.backward) velocity.z -= direction.z * 20.0 * delta;
  if(move.left || move.right) velocity.x -= direction.x * 20.0 * delta;
  controls.moveRight(-velocity.x*delta);
  controls.moveForward(-velocity.z*delta);

  // Raycast for crosshair targeting
  const raycaster = new THREE.Raycaster();
  raycaster.setFromCamera(new THREE.Vector2(0,0), camera);
  const intersects = raycaster.intersectObjects(shapes.map(s=>s.mesh));
  const cross = document.getElementById('crosshair');

  shapes.forEach(s => {
    // Reset scale
    s.mesh.scale.lerp(s.baseScale, 0.1);
  });

  if(intersects.length>0){
    cross.style.backgroundColor='#ff4444'; // red
    // Pulse the first intersected torus
    const target = intersects[0].object;
    const shape = shapes.find(s=>s.mesh===target);
    if(shape){
      const scaleFactor = 1 + 0.3*Math.sin(t*10);
      shape.mesh.scale.setScalar(scaleFactor);
    }
  } else {
    cross.style.backgroundColor='transparent';
  }

  renderer.render(scene, camera);

  // Sequencer
  if(Math.floor(t*4) > step){
    shapes.forEach((s,i)=>{
      if((step+i)%5===0){
        playNote(Cminor[i%Cminor.length], s);
      }
    });
    step = Math.floor(t*4);
  }
}
animate();

/* RESIZE */
window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

/* START AUDIO ON CLICK */
document.body.addEventListener('click',()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); });
</script>
</body>
</html>
